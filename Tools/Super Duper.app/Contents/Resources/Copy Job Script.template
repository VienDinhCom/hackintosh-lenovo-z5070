-- SuperDuper! scheduled copy script template (c) 2005-2015 by Bruce Lacey. Published by Shirt Pocket.-- Script by Dave Nanian and Bruce Laceyon beforeRunningCopy()	-- Put your own code here that should execute just before running the copy.end beforeRunningCopyon afterRunningCopy()	-- Put your own code here that should execute just after running a successful copy.end afterRunningCopyon errorRunningCopy(errorMsg)	-- Put your own code here that should execute in case of an error running the copy.	-- The errorMsg is the message that would be displayed by SuperDuper!end errorRunningCopy-- Note that the "quoteChar" and "backslashChar" variables are there to deal with improper handling-- of the backslash character in the Japanese OSX environment under Panther. Backslash and the Yen symbol are the-- same ASCII code, but the script compiler doesn't handle it properly, and the following characters-- are not escaped.-- Surprisingly, this compilation problem returned in Snow Leopard, so backslashChar must still be used.global backslashCharon encode_char(this_char)	local encodedChar	local characterAsHexDigits		set theChar to quoted form of this_char	set characterAsHexDigits to words of (do shell script "/bin/echo -n " & quoted form of this_char & " | od -X | tr '[:lower:]' '[:upper:]' | sed q | sed 's/0* *//' | sed 's/" & backslashChar & "([0-F][0-F]" & backslashChar & ")/" & backslashChar & "1 /g'")	set previousDelimiters to text item delimiters		-- Deal with the endianness of od on PPC and Intel. Only works if the Unicode character has a zero top byte & a non-zero bottom byte		set text item delimiters to " "		if first item of characterAsHexDigits is "00" then		set characterAsHexDigits to reverse of (items 2 thru -1 of characterAsHexDigits)	end if		set characterAsHexDigits to words of (do shell script "/bin/echo -n " & quoted form of (characterAsHexDigits as string) & " | sed 's/00//g'")		-- Deal with precomposed character sequences (not just Unicode), e.g. "Bigboot√©"	-- In this case, the regular character is followed by 0xcc then the modifier, so we have to change	-- the first byte back to ASCII.		if (count of characterAsHexDigits) is equal to 3 and item 2 of characterAsHexDigits is equal to "CC" then		set theNumber to 0		set numberString to item 1 of characterAsHexDigits		set placeValue to 16 ^ ((count of numberString) - 1)				repeat with currentCharacter in numberString			tell (offset of currentCharacter in "ABCDEF") + 9 to if it > 9 then set currentCharacter to it			set theNumber to theNumber + currentCharacter * placeValue			set placeValue to placeValue div 16		end repeat				set encodedChar to ASCII character theNumber		set characterAsHexDigits to items 2 thru -1 of characterAsHexDigits	else		set encodedChar to ""	end if		set text item delimiters to backslashChar & backslashChar & "%"	set encodedChar to encodedChar & backslashChar & backslashChar & "%" & characterAsHexDigits as string	set text item delimiters to previousDelimiters	return the encodedCharend encode_charon encode_text(this_text, encode_URL_A, encode_URL_B)	set the standard_characters to "abcdefghijklmnopqrstuvwxyz0123456789"	set quoteChar to ASCII character 34	set the URL_A_chars to "$+!',?;&@=#%><{}[]" & quoteChar & "~`^" & backslashChar & "|*()"	set the URL_B_chars to ".-_:"	set the acceptable_characters to the standard_characters	if encode_URL_A is false then set the acceptable_characters to the acceptable_characters & the URL_A_chars	if encode_URL_B is false then set the acceptable_characters to the acceptable_characters & the URL_B_chars	set the encoded_text to ""	repeat with this_char in this_text		if this_char is in the acceptable_characters then			set the encoded_text to (the encoded_text & this_char)		else			set the encoded_text to (the encoded_text & encode_char(this_char)) as string		end if	end repeat	return the encoded_textend encode_texton getDiskIDByName(volumeName)	local diskList	local currentItem	local oldDelimiters	local diskID	local systemVersion		set diskID to ""	tell application "System Events" to set systemVersion to (system version of (system info))		if (systemVersion starts with "10.4") or (systemVersion starts with "10.5") then		tell me to set diskList to do shell script "/usr/sbin/disktool -l"				repeat with currentItem in paragraphs of diskList			considering case				if contents of currentItem contains "'" & volumeName & "')" then					set oldDelimiters to get text item delimiters					set text item delimiters to "'"					set diskID to 2nd text item of currentItem					set text item delimiters to oldDelimiters					exit repeat				end if			end considering		end repeat	else		tell application "System Events" to set temporaryItemsFolder to the path to the temporary items folder from the user domain as string				set volumeListFile to (POSIX path of (temporaryItemsFolder & "com.shirtpocket.copyJob.diskList.plist"))				try			tell me to do shell script "/usr/sbin/diskutil info -plist " & quoted form of volumeName & " > " & quoted form of volumeListFile						try				tell application "System Events" to set diskID to value of property list item "DeviceIdentifier" of property list file volumeListFile			end try						tell me to do shell script "/bin/rm " & quoted form of volumeListFile		end try	end if		return diskIDend getDiskIDByNameon isDiskMountedByName(volumeName)	local diskList	local currentItem	local systemVersion		tell application "System Events" to set systemVersion to (system version of (system info))		if (systemVersion starts with "10.4") or (systemVersion starts with "10.5") then		tell me to set diskList to do shell script "/usr/sbin/disktool -l"				repeat with currentItem in paragraphs of diskList			considering case				if contents of currentItem contains "'" & volumeName & "')" then					if contents of currentItem contains "Mountpoint = ''" then						return false					else						return true					end if				end if			end considering		end repeat	else		set currentItem to ""				tell application "System Events"			set temporaryItemsFolder to the path to the temporary items folder from the user domain as string		end tell				set volumeListFile to (POSIX path of (temporaryItemsFolder & "com.shirtpocket.copyJob.diskList.plist"))				try			tell me to do shell script "/usr/sbin/diskutil info -plist " & quoted form of volumeName & " > " & quoted form of volumeListFile						try				tell application "System Events" to set currentItem to value of property list item "MountPoint" of property list file volumeListFile			end try						tell me to do shell script "/bin/rm " & quoted form of volumeListFile		end try				if currentItem is not equal to "" then return true	end if			return falseend isDiskMountedByNameon getKeyValueFromPath(settingsPath, plistFileName, myKeyName)	local mySettings	local myKeyValue	local theSettingsFile	local numParagraphs		set the text item delimiters to "/"		-- Locate and parse the settings plist		set sessionSettingFile to ((text items of settingsPath) & plistFileName) as string	set myKeyValue to ""		try		tell application "System Events"			set theSettingsFile to property list file sessionSettingFile			set myKeyValue to the value of the property list item myKeyName of theSettingsFile		end tell	end try		return myKeyValueend getKeyValueFromPathon mountCheck(settingsPath, mountOrUnmount)	local myDestinationVolumeName		set myDestinationVolumeName to my getKeyValueFromPath(settingsPath, "Session Settings.sdss", "SDtargetVolumeName")		if myDestinationVolumeName = "" then return false		-- Now, we have the name of the destination volume		if mountOrUnmount then		if not my isDiskMountedByName(myDestinationVolumeName) then			try				set diskID to my getDiskIDByName(myDestinationVolumeName)								if diskID is not equal to "" then					tell me to set resultOfMount to do shell script "/usr/sbin/diskutil mount " & diskID as string										-- Assumes the output of the result is in english...										if first word of resultOfMount is "Volume" and last word of resultOfMount is "mounted" then						repeat while not my isDiskMountedByName(myDestinationVolumeName)							delay 1						end repeat												return true					end if				end if			end try		end if		return false	else		try			set diskID to my getDiskIDByName(myDestinationVolumeName)						if diskID is not equal to "" then				tell me to do shell script "/usr/sbin/diskutil unmount " & diskID as string			end if		end try	end ifend mountCheckon isTodayValidForScheduledSettings(settingsDocument)	local mySettings		-- If the environment variable 'IMMEDIATE' is set to YES, this is a 'Copy Now' run. Always valid.		if (system attribute "IMMEDIATE") is equal to "YES" then		return true	end if		-- Validate that the current date matches	-- our crontab specification as an AND, not an OR.		set the text item delimiters to "/"		-- If the job isn't in the "Scheduled Copies" folder, always say it's OK to run.	-- This allows a copy job to be used for other purposes too.		if text item -2 of settingsDocument is not equal to "Scheduled Copies" then return true		set mySettings to my encode_text(last text item of settingsDocument, true, false)		try		tell me to set crontabEntry to do shell script "/usr/bin/crontab -l  | grep '" & mySettings & "'"	on error		-- If we couldn't find our own scheduled run in the crontab, it's not safe to continue.		return false	end try		if crontabEntry = "" then return false		-- Cron requires tab as delimiter		set the text item delimiters to "	"	set daySpec to 3rd text item of crontabEntry	set weekdaySpec to 5th text item of crontabEntry		if weekdaySpec is not equal to "*" then		-- Under Panther, weekday can't be directly coerced to an Integer.		-- So, do it manually.				set weekdayList to {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday}				repeat with theWeekday from 1 to 7			if (weekday of (current date)) is equal to item theWeekday of weekdayList then				exit repeat			end if		end repeat				if (weekdaySpec does not contain ((theWeekday - 1) as string)) then			return false		end if	end if		-- We know we're on the right weekday. Now, make sure	-- it's the one we want.		-- In the crontab, 1-7 is "1st", 8-14 is "2nd", etc.	-- Find out which one we are...		set theDay to (day of (current date)) as integer		if theDay is less than or equal to 7 then		set weekSpec to "1-7"	else if theDay is less than or equal to 14 then		set weekSpec to "8-14"	else if theDay is less than or equal to 21 then		set weekSpec to "15-21"	else		set weekSpec to "22-31"	end if		if (daySpec is not equal to "*") and (daySpec does not contain weekSpec) then		return false	end if		-- At this point, we know we're on the right day, with an ANDed evaluation	-- Let the caller know.		return trueend isTodayValidForScheduledSettings-- Have to avoid using System Events "process" or we'll generate a security error on Mavericks-- and lateron isSuperDuperRunning()	try		do shell script "ps x -o comm | grep '/SuperDuper!$'"	on error		return false	end try		return trueend isSuperDuperRunningon runningGrowls()	local potentialGrowls		set potentialGrowls to ""	-- First check for old Growl implementation		try		tell me to set potentialGrowls to do shell script "ps x -o comm | grep '/GrowlHelperApp$'"	on error		try			tell me to set potentialGrowls to do shell script "ps x -o comm | grep '/Growl$'"		end try	end try	-- If no old Growls available, check for new Growl		-- Now extract the application path for tell blocks	if potentialGrowls is not equal to "" then		local oldDelimiters		set oldDelimiters to the text item delimiters		set the text item delimiters to "/"				-- Get rid of everything after the .app				set potentialGrowls to (text items 1 through -4 of potentialGrowls) as string		set the text item delimiters to oldDelimiters	end if		return potentialGrowlsend runningGrowlson isGrowlRunning()	return (my runningGrowls() is not equal to "")end isGrowlRunning-- Fire off a Growl notification. Have to use raw event syntax and an indirect "tell" clause to avoid-- compilation problems when user doesn't have Growl installed.on sendGrowlNotification(notifyName, notifyTitle, notifyDescription)	if my isGrowlRunning() then		local growlApp				set growlApp to my runningGrowls()				tell my application growlApp			«event notifygr» given «class name»:notifyName, «class titl»:notifyTitle, «class desc»:notifyDescription, «class appl»:"SuperDuper!"		end tell	end ifend sendGrowlNotificationon getSettingsPath(currentContextPath)	local previousTextItemDelimiters	local pathToSettingsDocument	local pathSegment	local sdspItem		set previousTextItemDelimiters to the text item delimiters	set the text item delimiters to "/"		set sdspItem to 1		repeat with pathSegment in text items of (POSIX path of currentContextPath)		if pathSegment contains ".sdsp" then			exit repeat		end if				set sdspItem to sdspItem + 1	end repeat		set pathToSettingsDocument to (text items 1 thru sdspItem of POSIX path of currentContextPath) as string	set text item delimiters to previousTextItemDelimiters	return pathToSettingsDocumentend getSettingsPathon run {}	local settingsDocumentPath	local previousSettings	local unmountAtEnd		try		tell application "System Events"			set currentLanguages to do shell script "defaults read -g AppleLanguages"						if first word of currentLanguages is equal to "ja" then				set backslashChar to ASCII character 128			else				set backslashChar to ASCII character 92			end if		end tell	on error		set backslashChar to ASCII character 92	end try		--  NOTE:  If you run this in the Script Editor, "path to me" returns the path to the script object in the script editor	-- So, if you want to test your script, you'll have to hardwire the path appropriately, or use 	-- Script Debugger, which doesn't have this problem.	-- Extract the settingsDocument. Can't use "container" because it doesn't work properly on FileVault	-- volumes (it doesn't handle symlinks in the path properly), so we extract it manually.		set settingsDocumentPath to getSettingsPath(path to me)		if my isTodayValidForScheduledSettings(settingsDocumentPath) is equal to false then return		set the text item delimiters to "/"		-- Set a little mutex to handle the case where two instances of the script	-- driver start at the same time. Note that since lockfile was removed in El Capitan (10.11),	-- we've included a copy in our application package, which must be located since the user	-- could have renamed and moved it		tell application "Finder"		do shell script quoted form of (POSIX path of ((get application file id "com.blacey.SuperDuper!") as string)) & "/Contents/MacOS/lockfile -5 -l 120 /tmp/com.shirtpocket.copyjob.lock"	end tell	-- Check to see if SuperDuper! is already running. If so, don't load	-- the document to open SD!: wait for idle. This prevents the UI from	-- being snatched away from the user.		set startedWithSuperDuperRunning to isSuperDuperRunning()		tell application "SuperDuper!"				-- We use an extended timeout because the settings might put the computer to sleep,		-- and we might be waiting on a completion when we return.				with timeout of 1000000 seconds			try				-- If SuperDuper! isn't already running, launch it with the lauch event.				-- This will not load any settings, so no disk prompts will appear.								if not startedWithSuperDuperRunning then launch								-- Now that we know SuperDuper! is running, we can allow the other jobs to start.				-- This will prevent multiple launches of SD! under Leopard.								tell me to do shell script "/bin/rm -f /tmp/com.shirtpocket.copyjob.lock"								-- Wait until SuperDuper! is idle before loading and running the desired copy				-- This ensures an active user doesn't have SD! snagged away from				-- them. Also, wait for any current executions to complete.								repeat while (status is not idle) and (status is not done)					-- Sleep # seconds is the best way to "wait" without unneccessarily taxing the CPU					-- Delay, believe it or not, eats CPU.					tell me to do shell script "/bin/sleep 5"				end repeat								if startedWithSuperDuperRunning then					set previousSettings to path of current settings										try						tell me to set previousSettings to ((POSIX file previousSettings) as alias)					on error						-- If there were no settings loaded, we'll get an error. In that case,						-- we were sitting launched but not loaded: handle that like we weren't						-- running at all.												set startedWithSuperDuperRunning to false					end try				end if								-- Check if the volume is mounted; if not, try to mount it before starting								set unmountAtEnd to my mountCheck(settingsDocumentPath, true)								-- Call any custom "before copy" action				my beforeRunningCopy()								-- Actually run the copy operation. Does not block!				run using settings settingsDocumentPath without user interaction								-- If we mounted the volume before we started, schedule it to be unmounted when SuperDuper! quits				-- This will stay pending until all other scheduled copies are done to ensure				-- the general volume handling works properly with multiple copies.								if unmountAtEnd is equal to true then					eject the target volume of the current settings				end if								-- Wait until the session is done (done = success, error = failure)				-- Check to see if the process is still there to prevent re-launch								repeat while my isSuperDuperRunning()					if status is not equal to running then exit repeat										-- Sleep # seconds is the best way to "wait" without unneccessarily taxing the CPU					tell me to do shell script "/bin/sleep 5"				end repeat								if my getKeyValueFromPath(settingsDocumentPath, ".scheduledJobProperties", "SDExitStatus") is equal to "normal" then					my sendGrowlNotification("Scheduled Copy Succeeded", "SuperDuper! Copy Succeeded", "Copy of " & my getKeyValueFromPath(settingsDocumentPath, "Session Settings.sdss", "SDsourceVolumeName") & " to " & my getKeyValueFromPath(settingsDocumentPath, "Session Settings.sdss", "SDtargetVolumeName") & " was successful.")										-- Call any custom "after copy" action					my afterRunningCopy()				else					my sendGrowlNotification("Scheduled Copy Failed", "SuperDuper! Copy Failed", "Copy of " & my getKeyValueFromPath(settingsDocumentPath, "Session Settings.sdss", "SDsourceVolumeName") & " to " & my getKeyValueFromPath(settingsDocumentPath, "Session Settings.sdss", "SDtargetVolumeName") & " failed. See the log in the Scheduled Copies window for details.")										-- Call the user's code					my errorRunningCopy("Error occurred during copy.")				end if							on error errMsg				my sendGrowlNotification("Scheduled Copy Failed", "SuperDuper! Copy Failed", "Copy of " & my getKeyValueFromPath(settingsDocumentPath, "Session Settings.sdss", "SDsourceVolumeName") & " to " & my getKeyValueFromPath(settingsDocumentPath, "Session Settings.sdss", "SDtargetVolumeName") & " failed. " & errMsg)								-- Call the user's code				my errorRunningCopy(errMsg)			end try						-- Once done, if SuperDuper! wasn't running, tell it to quit as long as it's still there.			-- The quit will stay pending until all other scheduled copies are complete.						try				if my isSuperDuperRunning() then					if (not startedWithSuperDuperRunning) then						quit without saving					else if previousSettings is not equal to "" then						-- Otherwise, restore the settings the user had already selected.						open previousSettings					end if				end if			on error errMessage number errNum				if errNum is equal to -1712 then					-- Ignore any timeouts: likely due to a sleeping Macintosh (asleep for days).				else if errNum is equal to -2753 then					-- Ignore 'previousSettings not defined'				else					-- Probably SD was quit, no sense displaying error errMessage number errNum				end if			end try		end timeout	end tellend run